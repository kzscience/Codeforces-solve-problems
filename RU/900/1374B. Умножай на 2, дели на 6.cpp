/* 1374B. Умножай на 2, дели на 6 - (https://codeforces.com/problemset/problem/1374/B)
1) ограничение по времени на тест 1 секунда
2) ограничение по памяти на тест 256  мегабайт
3) ввод стандартный ввод
4) вывод стандартный вывод
*/

/*
Вам дано целое число n. За один ход вы можете или умножить n на 2, или разделить n на 6 (если оно делится на 6

без остатка).

Ваша задача — найти минимальное количество ходов, необходимое, чтобы получить 1
из n

или определить, что это невозможно.

Вам нужно ответить на t
независимых наборов тестовых данных.
*/

/*
Входные данные
Первая строка теста содержит одно целое число t (1≤t≤2⋅10^4) — количество наборов тестовых данных. Затем следуют t

наборов тестовых данных.

Единственная строка набора тестовых данных содержит одно целое число n
(1≤n≤10^9).

Выходные данные
Для каждого набора тестовых данных выведите ответ на него — минимальное количество ходов, необходимое, чтобы получить 1 из n, если это возможно, или -1, 
если невозможно получить 1 из n.
*/

/* Примеры:
Входные данные:
7
1
2
3
12
12345
15116544
387420489
Выходные данные:
0
-1
2
-1
-1
12
36
Примечание:
Рассмотрим шестой набор тестовых данных примера. Ответ может быть получен следующей последовательностью ходов из заданного числа 15116544:

Разделим на 6 и получим 2519424;
разделим на 6 и получим 419904;
разделим на 6 и получим 69984;
разделим на 6 и получим 11664;
умножим на 2 и получим 23328;
разделим на 6 и получим 3888;
разделим на 6 и получим 648;
разделим на 6 и получим 108;
умножим на 2 и получим 216;
разделим на 6 и получим 36;
разделим на 6 и получим 6;
разделим на 6 и получим 1. 
*/

﻿#include <iostream>
using namespace std;

int main()
{
	int x;
	cin >> x;
	while (x--) {
		int n;
		cin >> n;
		int s = 0, s1 = 0;
		while (n % 2 == 0) {
			n /= 2;
			++s;
		}
		while (n % 3 == 0) {
			n /= 3;
			++s1;
		}

		if (n == 1 && s <= s1) {
			cout << 2 * s1 - s << endl;
		}
		else {
			cout << -1 << endl;
		}
	}

	
	return 0;
}
 
